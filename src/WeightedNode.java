import java.util.Random;

/**
 * <h1>The Weighted Node</h1>
 * This node class has a similar structure to the node class but it includes weights and points to other pointers.
 * This works with relation to the nodes that point to it. The class takes in all these weights and nodes and gets a net sum of them.
 * The net sum is then passed to an activation function which determines the final input value of the node.
 *
 * @author Trevor Austin
 * @version 1.0
 * @since 26/05/2015
 */
public class WeightedNode extends AbstractNode {
    /**
     *
     */
    private double[] previousWeightChange;
    /**
     * This variable stores the weights for all nodes related to this node.
     */
    private double[] weights;
    /**
     * This variable stores pointers to all the nodes.
     */
    AbstractNode[] nodes;
    /**
     * This is function used to activate the node.
     */
    ActivationFunction activationFunction;

    /**
     * TODO Add comment
     */
    Node bias;

    //TODO Update comments

    /**
     * This default constructor returns an error as the constructor cannot implemented correctly at this time.
     */
    public WeightedNode() {

        System.out.println("Weights were not set");
    }

    /**
     * Returns the bias value
     *
     * @return Returns the bias Node
     */
    public Node getBias() {
        return bias;
    }

    /**
     * This is the overloaded constructor of the class and allows the user to set the nodes pointed to and the current activation function.
     *
     * @param nodes              These are the nodes currently pointed to by the user.
     * @param activationFunction This is activation function that will be used.
     */
    public WeightedNode(AbstractNode[] nodes, ActivationFunction activationFunction) {
        this.nodes = nodes;
        this.activationFunction = activationFunction;
        bias = new Node(-1);
        weights = new double[nodes.length + 1];
        previousWeightChange = new double[nodes.length+1];
        generateWeights();
    }

    /**
     * This function will randomly generate the weights for the nodes.
     * It will only generate weights when the weights member variable has been set.
     */
    private void generateWeights() {
        //TODO Throw an error
        if (weights.length == 0)
            return;
        double fanin = weights.length;
        for (int i = 0; i < weights.length; i++) {
            weights[i] =  doubleRandomInclusive(1/Math.sqrt(weights.length), -1/Math.sqrt(weights.length));
            previousWeightChange[i] = 0;
        }
    }

    private double doubleRandomInclusive(double max, double min) {
        double r = Math.random();
        if (r < 0.5) {
            return ((1 - Math.random()) * (max - min) + min);
        }
        return (Math.random() * (max - min) + min);
    }

    /**
     * Generates the input of the class using the net sum and the activation function. The net sum is generated by getting the sum of
     * the products of all the inputs and weights. Then the activation function is applied to the net sum.
     */
    private void generateInput() {
        double net = 0;
        for (int i = 0; i < nodes.length; i++) {
            net += nodes[i].getInput() * weights[i];
        }
        net += bias.getInput() * weights[nodes.length];
        input = activationFunction.activate(net);
    }

    /**
     * TODO Comments
     * @param outSigErr
     * @param hidSigErr
     * @return
     */
    public double[] getHidSigErr(double outSigErr, double[] hidSigErr) {

        for (int j = 0; j < nodes.length; j++) {
                double hidIn = nodes[j].getInput();
                hidSigErr[j] += outSigErr * weights[j] * (1 - hidIn) * hidIn;
        }
        return hidSigErr;
    }

    public void updateWeights(double learningRate, double errorSignal, double momentum){
            for(int i = 0; i < weights.length; i++){
                if(i<weights.length-1){
                    double previousWeight = -learningRate*errorSignal*nodes[i].getInput()+momentum*previousWeightChange[i];
                    weights[i] += previousWeight;
                    previousWeightChange[i] = previousWeight;
                }else{
                    double previousWeight = -learningRate*errorSignal*bias.getInput()+momentum*previousWeightChange[i];
                    weights[i] += previousWeight;
                    previousWeightChange[i] = previousWeight;
                }

            }
    }


    /**
     * TODO Comment
     *
     * @return
     */
    @Override
    public double getInput() {
        generateInput();
        return input;
    }
}
